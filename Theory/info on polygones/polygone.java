// Coursework1 for CSMGAA 23/20/98
//
// Jeffrey J. Gosper    
//
// Helium account gosperj
//
// Programming language JAVA (JDK 1.1.5)
//
//NB: This application reads/writes to files as required
//    however it also produces an interactive GUI.
//
// This is the main file containing a number of classes however 
// a series of additional classes are required for its operation.
// These include:
//      myQuitDialog
//      myModalDialog
//      myAboutDialog
//      myDialogBox
//      myMsgBox

    /**
     * A program to draw, manipulate, and write/read polygons.
     * Further the polygon is tested for convexity, its area, and
     * simplicity. The results of these tests are continually updated
     * on the screen as the polygons shape is changed.
     *
     * @author Jeffrey J. Gosper
     *
     * @version 1.1 22.10.98
	 */

import java.awt.*;
import java.util.*;     // Required for the vector
import java.io.*;

public class polygone extends Frame
{
    polygonClass poly1;
	iPoint currentPoint;    //Used to store a current point selected by a right mouse press

	public polygone(String filenam)
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.

	    poly1 = new polygonClass();    // Create a new (empty) polygon

		//{{INIT_CONTROLS
		setLayout(null);
		setVisible(false);
		setSize(405,413);
		setFont(new Font("Dialog", Font.PLAIN, 12));
		openFileDialog1 = new java.awt.FileDialog(this);
		openFileDialog1.setMode(FileDialog.LOAD);
		openFileDialog1.setTitle("Open");
		//$$ openFileDialog1.move(360,282);
		label1 = new java.awt.Label("Polygon - Draw and Test",Label.CENTER);
		label1.setBounds(6,6,384,30);
		label1.setFont(new Font("Dialog", Font.PLAIN, 22));
		add(label1);
		label2 = new java.awt.Label("by Dr Jeffrey J. Gosper",Label.CENTER);
		label2.setBounds(6,30,372,30);
		label2.setFont(new Font("Dialog", Font.ITALIC, 16));
		label2.setForeground(new Color(255));
		add(label2);
		label4 = new java.awt.Label("Cursor at:");
		label4.setBounds(270,126,56,24);
		add(label4);
		label5 = new java.awt.Label("(0 , 0)");
		label5.setBounds(288,150,78,24);
		add(label5);
		buttonClear = new java.awt.Button();
		buttonClear.setLabel("Clear");
		buttonClear.setBounds(270,240,102,24);
		buttonClear.setBackground(new Color(12632256));
		add(buttonClear);
		label3 = new java.awt.Label("To add a node press the left mouse button");
		label3.setBounds(6,66,264,18);
		label3.setForeground(new Color(4210752));
		add(label3);
		label6 = new java.awt.Label("To move a point use a right-mouse button drag");
		label6.setBounds(6,84,264,18);
		label6.setForeground(new Color(4210752));
		add(label6);
		checkCoords = new java.awt.Checkbox("Coords Visible");
		checkCoords.setBounds(270,180,108,20);
		add(checkCoords);
		label7 = new java.awt.Label("Note: New points are inserted in the red edge.");
		label7.setBounds(6,102,264,18);
		label7.setForeground(new Color(4210752));
		add(label7);
		checkNumbersVisible = new java.awt.Checkbox("Point # Visible");
		checkNumbersVisible.setBounds(270,204,108,20);
		//checkNumbersVisible.setBackground(new Color(16777215));
		add(checkNumbersVisible);
		//}}

		// Add my own canvas
		canvas1 = new DrawVectorCanvas();
		canvas1.setBounds(6,125,250,250);
		canvas1.setBackground(new Color(16756655));
		add(canvas1);

		//{{INIT_MENUS
		mainMenuBar = new java.awt.MenuBar();
		menu1 = new java.awt.Menu("File");
		miOpen = new java.awt.MenuItem("Open...");
		miOpen.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_O,false));
		menu1.add(miOpen);
		miSave = new java.awt.MenuItem("Save");
		miSave.setShortcut(new MenuShortcut(java.awt.event.KeyEvent.VK_S,false));
		menu1.add(miSave);
		menu1.addSeparator();
		miExit = new java.awt.MenuItem("Exit");
		menu1.add(miExit);
		mainMenuBar.add(menu1);
		menu3 = new java.awt.Menu("Help");
		mainMenuBar.setHelpMenu(menu3);
		miAbout = new java.awt.MenuItem("About..");
		menu3.add(miAbout);
		mainMenuBar.add(menu3);
		setMenuBar(mainMenuBar);
		//$$ mainMenuBar.move(324,282);
		//}}

		//{{REGISTER_LISTENERS
		SymWindow aSymWindow = new SymWindow();
		this.addWindowListener(aSymWindow);
		SymMouseMotion aSymMouseMotion = new SymMouseMotion();
		canvas1.addMouseMotionListener(aSymMouseMotion);
		SymMouse aSymMouse = new SymMouse();
		canvas1.addMouseListener(aSymMouse);
		SymAction lSymAction = new SymAction();
		buttonClear.addActionListener(lSymAction);
		canvas1.addMouseMotionListener(aSymMouseMotion);
		SymItem lSymItem = new SymItem();
		checkCoords.addItemListener(lSymItem);
		checkNumbersVisible.addItemListener(lSymItem);
		miOpen.addActionListener(lSymAction);
		miSave.addActionListener(lSymAction);
		miAbout.addActionListener(lSymAction);
		miExit.addActionListener(lSymAction);
		//}}

	    // Read the data in either the provided filename or the default filename 'data'.
	    // These are required to be in the current directory or
	    // in a directory within the default path, if present
	    // NB: The readFile returns a boolean however this is ignored here.
	    if (filenam=="")
	        filenam="data";
	    readFile(filenam);
	}

    /**
     * Shows or hides the component depending on the boolean flag b.
     * @param b  if true, show the component; otherwise, hide the component.
     * @see java.awt.Component#isVisible
     */
    public void setVisible(boolean b)
	{
		if(b)
		{
			setLocation(50, 50);
		}
		super.setVisible(b);
	}

    /**
     * Reads a file containing (x,y) coordinates (one pair on each line separated by a space)
     * @param filenm specifies the filename of the file
     * @return a boolean, if true indicates a sucessful read
	 */
	private boolean readFile(String filenm)
	{
        Vector vectTemp = new Vector();

	    try
	    {
	        FileInputStream fis = new FileInputStream(filenm);
	        DataInputStream dis =  new DataInputStream(fis);
	        while (true)
	        {
    	        String str= new String(dis.readLine());
    	        int posSpace = str.lastIndexOf(" ");
    	        String str1 = str.substring(0,posSpace);
    	        String str2 = str.substring(posSpace+1,str.length());
        		int x = Integer.parseInt(str1);
        		int y = Integer.parseInt(str2);
        		iPoint p = new iPoint(x,y);
        		vectTemp.addElement(p);
	        }
	    }
	    // Catch an error due to the file being in the wrong format
	    catch(NumberFormatException e)
	    {
		    new myMsgBox(this, "Messages","Error in format of input file").setVisible(true);;
	    }
	    // Catch other errors. This is primarily used to handle the termination of reading data at the EOF
	    catch(Exception e){}

        // From the data read in and generate a polygon. Note that as the polygon class automatically handles
        // the looping back the final point does not have to be added.
        if (vectTemp.size()>0)
            for (int i = 0; i<vectTemp.size()-1; i++)
	            poly1.addPoint((iPoint)vectTemp.elementAt(i));
	    if (vectTemp.size()>0)
	        return true;    // The read has been successful
	    else
	        return false;   // The read has been unsuccessful
	}

	/**
	 * Starting point for the application. The name of an input file
	 * can be the first argument. This is the only argument passed to the constuctor
	 */
	static public void main(String args[])
	{
	    if (args.length!=0)
		    (new polygone(args[0])).setVisible(true);
		else
		    (new polygone("data")).setVisible(true);

	}

	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension d = getSize();

		super.addNotify();

		if (fComponentsAdjusted)
			return;

		// Adjust components according to the insets
		setSize(insets().left + insets().right + d.width, insets().top + insets().bottom + d.height);
		Component components[] = getComponents();
		for (int i = 0; i < components.length; i++)
		{
			Point p = components[i].getLocation();
			p.translate(insets().left, insets().top);
			components[i].setLocation(p);
		}
		fComponentsAdjusted = true;
	}

	// Used for addNotify check.
	boolean fComponentsAdjusted = false;

	//{{DECLARE_MENUS
	java.awt.MenuBar mainMenuBar;
	java.awt.Menu menu1;
	java.awt.MenuItem miOpen;
	java.awt.MenuItem miSave;
	java.awt.MenuItem miExit;
	java.awt.Menu menu3;
	java.awt.MenuItem miAbout;
	//}}

	// Setup listeners for the window
	class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosing(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			if (object == polygone.this)
				polygone_WindowClosing(event);
		}
	}

	void polygone_WindowClosing(java.awt.event.WindowEvent event)
	{
		setVisible(false);	// hide the Frame
		dispose();			// free the system resources
		System.exit(0);		// close the application
	}

	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (object == miOpen)
				miOpen_Action(event);
			else if (object == miSave)
				miSave_Action(event);
			else if (object == miAbout)
				miAbout_Action(event);
			else if (object == miExit)
				miExit_Action(event);
			else if (object == buttonClear)
				buttonClear_ActionPerformed(event);
		}
	}

	void miAbout_Action(java.awt.event.ActionEvent event)
	{
		//{{CONNECTION
		// Action from About Create and show as modal
		(new myAboutDialog(this, true)).setVisible(true);
		//}}
	}

	void miExit_Action(java.awt.event.ActionEvent event)
	{
		//{{CONNECTION
		// Action from Exit Create and show as modal
		(new myQuitDialog(this, true)).setVisible(true);
		//}}
	}

	void miOpen_Action(java.awt.event.ActionEvent event)
	{
		//{{CONNECTION
		// Action from Open... Show the OpenFileDialog
		int		defMode			= openFileDialog1.getMode();
		String	defTitle		= openFileDialog1.getTitle();
		String defDirectory	= openFileDialog1.getDirectory();
		String defFile			= openFileDialog1.getFile();

		openFileDialog1 = new java.awt.FileDialog(this, defTitle, defMode);
		openFileDialog1.setDirectory(defDirectory);
		openFileDialog1.setFile(defFile);
		openFileDialog1.setVisible(true);
		//}}

		//get the filename, and valid read the data and draw the polygon
		String fileName=openFileDialog1.getFile();
		if(fileName!=null)
		{
		    poly1.clear();
		    readFile(fileName);
		    canvas1.repaint();
	    }
	}

	void miSave_Action(java.awt.event.ActionEvent event)
	{
		//{{CONNECTION
		// Action from Save... Show the OpenFileDialog
		String	defTitle		= openFileDialog1.getTitle();
		String defDirectory	= openFileDialog1.getDirectory();
		String defFile			= openFileDialog1.getFile();

		saveAsFileDialog1 = new java.awt.FileDialog(this, defTitle, FileDialog.SAVE);
		saveAsFileDialog1.setDirectory(defDirectory);
		saveAsFileDialog1.setFile(defFile);
		saveAsFileDialog1.setVisible(true);
		//}}

		String fileName=saveAsFileDialog1.getFile();

		if(fileName!=null)
		{
		    if(poly1.getSize()>0)
		        if(!(poly1.writeData(fileName)))
		            new myMsgBox(this, "Messages","Error writing data").setVisible(true);

	    }
	}

	//{{DECLARE_CONTROLS
	java.awt.FileDialog openFileDialog1;
	java.awt.FileDialog saveAsFileDialog1;
	java.awt.Label label1;
	java.awt.Label label2;
	java.awt.Label label4;
	java.awt.Label label5;
	java.awt.Button buttonClear;
	java.awt.Label label3;
	java.awt.Label label6;
	java.awt.Checkbox checkCoords;
	java.awt.Label label7;
	java.awt.Checkbox checkNumbersVisible;
	//}}
	DrawVectorCanvas canvas1;

    /**
     * Creates a canvas and draws a polyon on it
	 */
    public class DrawVectorCanvas extends Canvas
    {
        public void paint(Graphics g)
        {
            poly1.draw(g);
        }
    }

    // Set up mouse listeners (drag/move)
	class SymMouseMotion extends java.awt.event.MouseMotionAdapter
	{
		public void mouseDragged(java.awt.event.MouseEvent event)
		{
			Object object = event.getSource();
			if (object == canvas1)
				canvas1_MouseDragged(event);
		}

		public void mouseMoved(java.awt.event.MouseEvent event)
		{
			Object object = event.getSource();
			if (object == canvas1)
				canvas1_MouseMoved(event);
		}
	}

	void canvas1_MouseMoved(java.awt.event.MouseEvent event)
	{
		//{{CONNECTION
		// Get the cursor and display its position
		// The canvas is 250 wide and high
		// The position is relative to the centre of the canvas and with up as positive Y
		int newx = event.getX()-125;
		int newy = -1*(event.getY()-125);
		label5.setText("(" + newx + "," + newy + ")");
		//}}
	}

	void canvas1_MouseClicked(java.awt.event.MouseEvent event)
	{
		//{{CONNECTION
		iPoint p = new iPoint(event.getX()-125,event.getY()+125);
		poly1.addPoint(p);
        canvas1.repaint();
		//}}
	}

	void buttonClear_ActionPerformed(java.awt.event.ActionEvent event)
	{
		//{{CONNECTION
        poly1.clear();
        canvas1.repaint();
        //}}
	}

	void canvas1_MouseDragged(java.awt.event.MouseEvent event)
	{
		//{{CONNECTION
		// Get the cursor and display its position
		int newx = event.getX()-125;
		int newy = -1*(event.getY()-125);
		label5.setText("(" + newx + "," + newy + ")");
		// Find whether a point is within +/-5 of existing point
		if (currentPoint!=null)
		{
		    if (event.getModifiers()!=java.awt.event.MouseEvent.BUTTON1_MASK)
		    {
    		    int dist = currentPoint.get_DistSQR(event.getX(), event.getY());
		        newx = event.getX()-125;
		        newy = -1*(event.getY()-125);
                poly1.moveiPointAbs(currentPoint,newx, newy);
                canvas1.repaint();
		    }
		}
		//}}
	}

    // Setup a mouse listener for a button press
	class SymMouse extends java.awt.event.MouseAdapter
	{
		public void mousePressed(java.awt.event.MouseEvent event)
		{
			Object object = event.getSource();
			if (object == canvas1)
				canvas1_MousePressed(event);
		}
	}

    /**
     * A left button mouse press creates a new point
     * A right mouse button press finds the closest point to the cursor
     * The letter is used so that a drag event operates on the selected point
	 */
	void canvas1_MousePressed(java.awt.event.MouseEvent event)
	{
		//{{CONNECTION
		int newx = event.getX()-125;
		int newy = -1*(event.getY()-125);
		if (event.getModifiers()==java.awt.event.MouseEvent.BUTTON1_MASK)
		{
    		iPoint p = new iPoint(newx, newy);
    		poly1.addPoint(p);
            canvas1.repaint();
            currentPoint=null;  // Required so that a left-mouse click followed by a drag does not do anything
		}
		else
			currentPoint = poly1.getClosest(newx, newy);
		//}}
	}

	class SymItem implements java.awt.event.ItemListener
	{
		public void itemStateChanged(java.awt.event.ItemEvent event)
		{
			Object object = event.getSource();
			if (object == checkCoords)
				checkCoords_ItemStateChanged(event);
			if (object == checkNumbersVisible)
				checkNumbersVisible_ItemStateChanged(event);
		}
	}

	void checkCoords_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		//{{CONNECTION
		// Update and Repaint the Canvas
		poly1.setCoordsVisible(checkCoords.getState());
		canvas1.repaint();
		//}}
	}
	void checkNumbersVisible_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		//{{CONNECTION
		// Update and Repaint the Canvas
		poly1.setNumbersVisible(checkNumbersVisible.getState());
		canvas1.repaint();
		//}}
	}
}

class iPoint
{
    /**
	 * iPoint class
	 *   Description:
	 *   A simple class that holds the coordinates of a point, as an integer) on a 2D space
	 *   All the data is protected and only methods which do not effect the state of a point are public.
	 *   This prevents a point being created or moved within going through the polygon class. This is necessary
	 *   as the polygon class needs to keep track as to whether it is a simple polgon, etc.
	 *   Constructors:
	 *   This class contains overloaded constructors such that points can
	 *   be created using default values or from coordinates, or even another point.
	 *
	 *   Attributes:
	 *   A point only holds an X and Y integer value.
	 *
	 *   Methods:
	 *   Apart from simple get and set functions for its attributes
	 *   methods are provided to move the spot around in both
	 *   an absolute and relative sence. A method is also available to provide the distance
	 *   of the square of the point from a provided point.
     */

    // coordinates of the point
    protected int x;
    protected int y;
    // Constructor to create a point from its coordinates
    protected iPoint(int xVal, int yVal)
    {
        x = xVal;
        y = yVal;
    }
    // Constructor to create a point from another point
    //  i.e. copy constructor in C++ speak
    protected iPoint(iPoint point)
    {
        x = point.getX();
        y = point.getY();
    }
    protected iPoint()         //  Construct a new point from an existing point
    {
        x = 0;
        y = 0;
    }
    public int getX(){      // Return X coordinate
        return x;}
    public int getY(){      // Return X coordinate
        return y;}
    protected void setX(int xnew){ // Set X coordinate
        x = xnew;}
    protected void setY(int ynew){ // Set Y coordinate
        y = ynew;}
    // Move the point - absolute
    protected void moveiPointAbs(int xnew, int ynew)
    {
        x = xnew;
        y = ynew;
    }
    // Move the point - relative
    protected void moveiPointRel(int xdelta, int ydelta)
    {
        x += xdelta;
        y += ydelta;
    }
    // Return square of distance (is an integer)
    public int get_DistSQR(int xpos, int ypos)
    {
        int dist1_sqr = xpos-x;
        dist1_sqr *= dist1_sqr;     //sqr the number
        int dist2_sqr = ypos-y;
        dist2_sqr *= dist2_sqr;     //sqr the number
        return (dist1_sqr+dist2_sqr);
    }
}

class polygonClass
{
    /**
	* Polygon class
	*    Description:
    *    Essentially a vector of points with methods but also 'knows' whether it is a valid polygon or not.
    *    The first point also appears at the end of the vector so that the poygon is closed
    *
	*    Constructors:
	*    A default construct sets up the object with no points
	*
	*    Methods:
    *    NB: All methods are listed in alphabetical order
    *    addPoint - add points to the vector and determines whether the polygon is valid
    *    AreaTriangle2 - Calculates twice the area of a triangle defined by the three points provided to it as parameters
    *                    NB: Twice the area is always an integer. Therefore efficient integer opertaions only need to be performed
    *    calcArea2 - Calculates and returns the area of twice the area of the polygon (this ensures integer opertions are valid)
    *    checkIsConvex - Checks whether the polygon is convex and stores the result in the boolean variable isConvex
    *    checkIsValid - Checks whether the polygon is simple (not 'stray' intersceting edges) and stores the result in the boolean variable isValid
    *    clear - Remove all points from the polygon
    *    doIntersectProper - Test whether two lines (defined by the points a to b, and c to d) intersect properly (i.e. lines cross completely).
    *                        (from 'Computational Geometry in C', J. O'Rourke, code 1.6)
    *    doIntersect - Test whether lines (defined by the points a to b, and c to d) intersect either properly or improperly
    *                    (i.e. lines cross completely or just touch at one point.)
    *
    *    draw     - Draws the polygon, on the graphics object provided as a parameter, following the sequence of points along the vector
    *               and cycles back to the first point. Spots represent the nodes.
    *               Prints point coordinates and numbers if require
    *    getArea2 - Returns the area of the polygon
    *    getClosest - Finds the point closest to a provided coordinate pair
    *    getSize - returns the size of the vector holding the polygon (recall the first point is held twice)
    *    isBetween - determines whether a point (c) is between to other points (a,b)
    *    isColinear - determines whether three points are colinear
    *    isLeft - detrmines whether a third point is strictly left of an line defined by the first two points
    *    isLeftOn - detrmines whether a third point is is on or left of an line defined by the first two points
    *    isValidPolygon - returns whether the polygon is a simple polygon
    *    setCoordsVisible - sets the coodinate visibility flag to the provided boolean
    *    setNumbersVisible - sets the point label numbers visibility flag to the provided boolean
    *    updateStatus - Updates the variables holding the area*2, convexity booelan and simple polygon flag
    */
    Vector vect; // This holds the points of the polygon. Note the first point will be stored twise. Once at the beginning and once at the end.
    boolean isValid;        // Holds whether the polygon is a valid simple polygon
    boolean isConvex;       // Holdswhether the polygon is fully convex
    boolean coordsVisible;  // Holds whether the coordinates should be printed next to the points
    boolean numbersVisible;  // Holds whether the number of the point should be printed next to the points
    int area2;               // Holds the area of the polygon

    public polygonClass()    //Create an empty vector
    {
        vect = new Vector();
        isValid = false;
        isConvex = false;
    }

    public void addPoint(iPoint point)
    {
        // Reset the final point to the new point and add a point
        // then test the validity of polygon
        if (vect.size()>0)
        {
            vect.setElementAt(point,vect.size()-1);   // Change the last point to current
            vect.addElement(vect.elementAt(0));     // Add first point as last again
        }
        else    // No points exist so we need to create two for the start and end
        {
            vect.addElement(point);     // Add point as start
            vect.addElement(point);     // and as the end
        }
        updateStatus();     // As the polygon has changed the properties of the polygon (area2, convexity, validity) need updating
    }

    protected int AreaTriangle2(iPoint a, iPoint b, iPoint c)
    {
        // returns twice the signed area of the triangle,m positive is ccw from a to b to c
        return  a.getX()*b.getY()-a.getY()*b.getX() +
                a.getY()*c.getX()-a.getX()*c.getY() +
                b.getX()*c.getY()-c.getX()*b.getY();
    }

    protected void calcArea2()
    {
        if (vect.size()<3)
        {
            area2=0;
            return;
        }
        int sum = 0;  // Partial sum
        // Recall the last point is stroed twice threfore only need to evalated up to n-2 rather than n-1 as on p. 26
        // of Rourke's book.
        for (int i = 0; i<vect.size()-2; i++)
            sum += AreaTriangle2((iPoint)vect.elementAt(0), (iPoint)vect.elementAt(i),(iPoint)vect.elementAt(i+1));
        area2=sum;
    }

    protected void checkIsConvex()
    {
        // If there exists a right turn the polygon is not convex
        for (int i = 0; i < vect.size()-2; i++)
            if (isLeftOn((iPoint)vect.elementAt(i),(iPoint)vect.elementAt(i+1),(iPoint)vect.elementAt(i+2))==false)
            {
                isConvex=false;
                return;
            }
        // Finally test the corner around the first point.
            if (isLeftOn((iPoint)vect.elementAt(vect.size()-2),(iPoint)vect.elementAt(0),(iPoint)vect.elementAt(1))==false)
            {
                isConvex=false;
                return;
            }
        isConvex=true;
    }

    public void checkIsValid()
    {
        // Determine whether the polygon is valid
        // First there must be at least three points (i.e. four coordinates as the first is stored twise)
        if (vect.size()<4)
            isValid = false;
        else
        {
            // There can be no intersecting lines.
            // Assume no lines cross and then test for any crosses (below)
            // The check needs to be made for each pair of non-connected lines
            // So start with the first line and check the lines from points 2-to-3, 3-to-4, ... (n-2)-to-(n-1)
            // However as the first point is also stored as the end and there is a need for a test to catch this loop back
            //  as the first and last lines must touch as they have a common point
            //  This could be handled by treating the first or last as a special case but the test below ensures there is no problem.
            isValid=true;
            // A special test is needed for the first loop through the data as the start and end points touch
            for (int j=2; j<vect.size()-2;j++)
                if ((doIntersect((iPoint)vect.elementAt(0),(iPoint)vect.elementAt(1),(iPoint)vect.elementAt(j),(iPoint)vect.elementAt(j+1)))==true)
                {
                    isValid = false;
                    return;
                }
            for (int i=1; i<vect.size()-1;i++)
                for (int j=i+2; j<vect.size()-1;j++)
                  //if (!((i==0)&&(j==vect.size()-2)))
                    if ((doIntersect((iPoint)vect.elementAt(i),(iPoint)vect.elementAt(i+1),(iPoint)vect.elementAt(j),(iPoint)vect.elementAt(j+1)))==true)
                    {
                        isValid = false;
                        return;
                    }
        }
    }

    public void clear()    //Remove all points
    {
        vect.removeAllElements();
        isValid = false;
    }

    protected boolean doIntersectProper(iPoint a, iPoint b, iPoint c, iPoint d)
    {
        // Test whether lines intersect properly (i.e. lines cross completely).
        // (from 'Computational Geometry in C', J. O'Rourke, ode 1.6)
        if ((isColinear(a,b,c))||(isColinear(a,b,d))||(isColinear(c,d,a))||(isColinear(c,d,b)))
            return false;
        else
            return (isLeft(a,b,c)^isLeft(a,b,d)) && (isLeft(c,d,a)^isLeft(c,d,b));
    }

    protected boolean doIntersect(iPoint a, iPoint b, iPoint c, iPoint d)
    {
        // Test whether lines intersect properly or improperly (
        // i.e. lines cross completely or just touch at one point).
        // (from 'Computational Geometry in C', J. O'Rourke, ode 1.6)
        if ((doIntersectProper(a,b,c,d)))
            return true;
        else if (    isBetween(a,b,c)
                  || isBetween(a,b,d)
                  || isBetween(c,d,a)
                  || isBetween(c,d,b)
                )
                return true;
        else    return false;
    }

    public void draw(Graphics g)
    {
        if (vect.size()==0)
        {
            g.drawString("Please draw a polygon", 5, 25);
            return;
        }
        else
        {
            //draw all points as spots
            for(int i=0; i<vect.size()-1;i++) // No beed to draw last/last point twice
            {
                iPoint p = (iPoint)vect.elementAt(i);
                int newx = p.getX()+125;
                int newy = 125-p.getY();
                g.fillOval(newx-3,newy-3,5,5);
                //g.fillOval(p.getX()-3,p.getY()-3,5,5);
            }
            // Draw the last spot as red
            g.setColor(Color.red);
            iPoint p = (iPoint)vect.elementAt(vect.size()-1);
            int newx = p.getX()+125;
            int newy = 125-p.getY();
            g.fillOval(newx-3,newy-3,5,5);
            g.setColor(Color.black);
            // Draw the existing points in the vector
            for(int i = 0; i < vect.size()-2; i++)
            {
                iPoint p1=(iPoint)(vect.elementAt(i));
                iPoint p2 =(iPoint)(vect.elementAt(i+1));
                int newx1 = p1.getX()+125;
                int newy1 = 125-p1.getY();
                int newx2 = p2.getX()+125;
                int newy2 = 125-p2.getY();
                g.drawLine(newx1,newy1,newx2,newy2);
            }
            // The last line and point are to appear in red hence require special code
            g.setColor(Color.red);
            iPoint p1=(iPoint)(vect.elementAt(vect.size()-2));
            iPoint p2 =(iPoint)(vect.elementAt(vect.size()-1));
            int newx1 = p1.getX()+125;
            int newy1 = 125-p1.getY();
            int newx2 = p2.getX()+125;
            int newy2 = 125-p2.getY();
            g.drawLine(newx1,newy1,newx2,newy2);
            g.setColor(Color.black);

            // Determine whether points coordinates should be drawn and do so if required
            if (coordsVisible)
                for (int i=0; i<vect.size(); i++)
                {
                    p = (iPoint)vect.elementAt(i);
                    newx1 = p.getX()+125;
                    newy1=125-p.getY();
                    g.drawString("(" + p.getX() + "," + p.getY() + ")", newx1+5,newy1);
                }
            // Determine whether point numbers should be drawn and do so if required
            if (numbersVisible)
            {
                for (int i=0; i<vect.size()-1; i++)
                {
                    p = (iPoint)vect.elementAt(i);
                    newx1 = p.getX()+125;
                    newy1=125-p.getY();
                    // Offset x by 5 to right and Y 12 down so they don't overlap the point or the coordinates
                    g.drawString(""+i, newx1+5,newy1+12);
                }
            }
        }
        if (isValid)
        {
            g.drawString("2*Area = " + this.getArea2(), 5,30);
            g.drawString("Simple Polygon", 5,15);
            //System.out.print("proper polygon");
            //System.out.println();

            if (isConvex)
            {
                g.drawString("(Convex)",100,15);
                //System.out.print("convex");
                //System.out.println();
            }
            else
            {
                g.drawString("(Not Convex)",100,15);
                //System.out.print("not convex");
                //System.out.println();
            }
            //System.out.print(this.getArea2());
            //System.out.println();
        }
        else
        {
            g.drawString("2*Area = " + this.getArea2() + " invalid", 5,30);
            g.drawString("None Simple Polygon", 5,15);
        }
    }

    public int getArea2()
    {
        return area2;
    }

    public iPoint getClosest(int x, int y)
    {
        if (vect.size()<2) return null;
        iPoint point = (iPoint)vect.elementAt(0);
        int dist1_sqr = point.getX()-x;
        dist1_sqr *= dist1_sqr;     //sqr the number
        int dist2_sqr = point.getY()-y;
        dist2_sqr *= dist2_sqr;     //sqr the number
        int dist_sqr = dist1_sqr + dist2_sqr;
        for (int i=1; i<vect.size(); i++)
        {
            iPoint tempPoint = (iPoint)vect.elementAt(i);
            dist1_sqr = tempPoint.getX()-x;
            dist1_sqr *= dist1_sqr;     //sqr the number
            dist2_sqr = tempPoint.getY()-y;
            dist2_sqr *= dist2_sqr;     //sqr the number
            if ((dist1_sqr+dist2_sqr)<dist_sqr)
            {
                dist_sqr = dist1_sqr+dist2_sqr;
                point = (iPoint)vect.elementAt(i);
            }
        }
        return point;
    }

    public int getSize()
    {
        return vect.size();
    }

    protected boolean isBetween(iPoint a, iPoint b, iPoint c)
    {
        if (isColinear(a,b,c)==false)
            return false;
        // If line a-b not vertical check betweenness on x else on y
        if (a.getX() != b.getX())
            return ((a.getX()<=c.getX())&&(c.getX()<=b.getX())) || ((a.getX()>=c.getX())&&(c.getX()>=b.getX()));
        else
            return ((a.getY()<=c.getY())&&(c.getY()<=b.getY())) || ((a.getY()>=c.getY())&&(c.getY()>=b.getY()));
    }

    protected boolean isColinear(iPoint p1, iPoint p2, iPoint p3)
    {
        if (AreaTriangle2(p1,p2,p3)==0)
            return true;
        else
            return false;
    }

    protected boolean isLeft(iPoint p1, iPoint p2, iPoint p3)
    {
        if (AreaTriangle2(p1,p2,p3)>0)
            return true;
        else
            return false;
    }

    protected boolean isLeftOn(iPoint p1, iPoint p2, iPoint p3)
    {
        if (AreaTriangle2(p1,p2,p3)>=0)
            return true;
        else
            return false;
    }

    public boolean isValidPolygon()
    {
        return isValid;
    }

    public void moveiPointAbs(iPoint point, int newx, int newy)
    {
        point.moveiPointAbs(newx, newy);
        updateStatus();   //As a points position has chnaged we need to update the polygons properties
    }

    public void setCoordsVisible(boolean bool)
    {
        coordsVisible = bool;
    }
    public void setNumbersVisible(boolean bool)
    {
        numbersVisible = bool;
    }

    public boolean writeData(String filenm)
	{
	    try
	    {
	        FileOutputStream fos = new FileOutputStream(filenm);
	        DataOutputStream dos =  new DataOutputStream(fos);
	        for (int i=0; i<vect.size();i++)
	        {
    	        iPoint p = (iPoint)vect.elementAt(i);
    	        String str = "" + p.getX() + " " + p.getY() + "\n";
    	        dos.writeBytes(str);
            }
	        dos.flush();
	    }
	    catch(Exception e){return false;}
	    return true;
	}

    /**
     * Ensures that the derived information about a polygon is correct
	 */
    public void updateStatus()
    {
        checkIsValid();     // Check whether the polygon is still simple
        checkIsConvex();    // Check whether its still a valid convex poygon
        calcArea2();        // Recalculate its (area*2)
    }
}